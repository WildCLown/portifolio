<!DOCTYPE html>
<html>
 <head>
  
 </head>
 <title>"Mini Projeto 2 de PG"</title>
 <body onclick="refatorization()">
     <center>
        <h1>Trabalho faculdade de <a href="https://github.com/WildCLown">GTSA</a> e <a href="https://github.com/lionliu/">LLM2</a></h1>
       <canvas onclick="storePoint()" id="canvas" width="750" height="500" style = "border: 3px solid#000000;"></canvas>
    </center>
    <h2>Menu</h2>
        Numero Avaliacoes<input type="text" id="avaliatnumb" value = 25><br><br>
        <button onclick="CdoPoint()" id = "criar" >Nova Curva!</button>
        <button onclick="DeleteCurve()">Bang!</button>
        <button onclick="nextCurve()">Curva Anterior.</button>
        <button onclick="lastCurve()">Próxima Curva.</button>
    <br>
    <br>
    <input type="checkbox" name = "ControlPoint" checked> Pontos de Controle<br>
    <input type="checkbox" name = "PoliControl" checked> Poligonais de Controle<br>
    <input type="checkbox" name = "Curves" checked> Curvas<br><br>
</body>
<script type="application/javascript"> 
    var canvas = document.getElementById("canvas"); // pega o canvas
    canvas.onmousedown = myDown;
    canvas.onmouseup = myUp;
    var ctx = canvas.getContext("2d");
    var rect = canvas.getBoundingClientRect();
    var checkPoint = document.getElementsByName("ControlPoint");
    var matriz = [];
    var matrizaux = [];
    var doPoint;
    var aktObj = 0;
    var avaliat = 15;
    var dragok = false;
    var lastX;
    var lastY;

    var actualCurve;
    var actualPoint;

    function myMove(e) {
        if (dragok) {
            matriz[actualCurve][actualPoint * 2] = e.pageX - canvas.offsetLeft;
            matriz[actualCurve][(actualPoint * 2) + 1] = e.pageY - canvas.offsetTop;
            reset();
        }
    }

    function myDown(e) {
        for (var j = 0; j < matriz.length; j++) {
            var arraux = matriz[j];
            for (var i = 0; ((i * 2) + 1) < arraux.length; i++) {
                let x = arraux[i * 2];
                let y = arraux[(i * 2) + 1];
                
                if (e.pageX < x + 5 + canvas.offsetLeft && e.pageX > x - 5 +
                    canvas.offsetLeft && e.pageY < y + 5 + canvas.offsetTop &&
                    e.pageY > y - 5 + canvas.offsetTop) {
                    actualCurve = j
                    actualPoint = i;
                    arraux[i * 2] = e.pageX - canvas.offsetLeft;
                    arraux[(i * 2) + 1] = e.pageY - canvas.offsetTop;
                    dragok = true;
                    canvas.onmousemove = myMove;
                }
            }
            
        }
    }

    function myUp() {
        dragok = false;
        canvas.onmousemove = null;
    }
    
    function ifuwant(){
        //No caso, para fazer os pontos mudarem de posição, tem q primeiro achar, daí tem q procurar na matriz a curva,
        //e da curva, vê de 2 em 2 casas do array o par X e Y...
        //Nois
    }
    function refatorization(){
        avaliat = document.getElementById("avaliatnumb").value;
        reset();
    }
    function storePoint(){//Armazena o ponto em 1 array e manda desenhar
        if(doPoint){
            matrizaux.push(event.clientX-rect.left);
            matrizaux.push(event.clientY-rect.top);
            drawTHISPoint();
        }
    }
    function CdoPoint(){
        if(!doPoint){//Modificando botão e controle para 
            document.getElementById("criar").innerHTML = "Aperte aqui quando terminar de colocar os pontos";
            doPoint = true;
        }else{//Modifica botão, controle e coloca o vetor de pontos em outro vetor (matriz)
            document.getElementById("criar").innerHTML = "Nova Curva!"; 
            doPoint = false;
            if(matrizaux.length>0){
                matriz.push(matrizaux);
            }
            matrizaux = [];
            reset();
        }
    }
    function DeleteCurve(){//Deleta a curva selecionada
        matriz.splice(aktObj,1);//Retira um elemento do array a partir da posição aktObj
        if(aktObj>matriz.length-1){
            aktObj--;
        }
        if(aktObj < 0){
            aktObj=0;
        }
        alert("Essa curva morreu ;-;'");
        reset();
    }
    function nextCurve(){//Modifica o contador para saber em qual curva está
        if(aktObj>0){
            aktObj--;
            reset();
        }
    }
    function lastCurve(){//Modifica o contador para saber em qual curva está
        if(aktObj<matriz.length-1){
                aktObj++;
                reset();
            }
    }
    function drawTHISPoint(){//Desenha o ponto ASSIM que é clickado na tela
        var checkPoint = document.getElementsByName("ControlPoint");
        if(checkPoint[0].checked){//Verifica se a checkbox está marcada
            var arraux = matrizaux;
            for(var i = 0; ((i*2)+1)<arraux.length;i++){
                ctx.beginPath();
                //Desenha circulos de raios cada vez menores para ser um grande ponto
                ctx.arc(arraux[i*2],arraux[(i*2)+1],5, 0, 2 * Math.PI);
                ctx.fillStyle = '#000000';
                ctx.fill();
                ctx.stroke();
            }
        }
    }
    function drawPoints(){//Desenha TODOS os pontos da matriz
    //Lógica semelhante a anterior
        var checkPoint = document.getElementsByName("ControlPoint");
        if(checkPoint[0].checked){
            for(var j = 0; j<matriz.length;j++){
                var arraux = matriz[j];
                if(aktObj == j){//Verifica se o ponto é o que está selecionado na HUD
                    for(var i = 0; ((i*2)+1)<arraux.length;i++){
                        ctx.strokeStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.arc(arraux[i*2],arraux[(i*2)+1],5, 0, 2 * Math.PI);
                        ctx.fillStyle = '#FF0000';
                        ctx.fill();
                        ctx.stroke();
                        
                    }

                }else{
                    for(var i = 0; ((i*2)+1)<arraux.length;i++){
                        ctx.strokeStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(arraux[i*2],arraux[(i*2)+1],5, 0, 2 * Math.PI);
                        ctx.fillStyle = '#000000';
                        ctx.fill();
                        ctx.stroke();
                    } 
                }
            }
        }
    }
    function drawPoliCtrl(){//Desenha as poligonais de controle
    //Lógica semelhante a de pontos para pintura
        var checkPCtrl = document.getElementsByName("PoliControl"); 
        if(checkPCtrl[0].checked){
            for(var j = 0; j<matriz.length;j++){
                var arraux = matriz[j];
                ctx.moveTo(arraux[0],arraux[1]);//Se move para o primeiro ponto feito para começar a fazer as ligacoes
                if(aktObj === j){
                    ctx.strokeStyle = '#2bff00';
                    ctx.beginPath();
                    for(var i = 0; ((i*2)+1)<arraux.length;i++){
                        ctx.lineTo(arraux[i*2],arraux[(i*2)+1]);//Liga o ponto atual com o próximo ponto
                        //arraux possui nele mesmo o X e o Y, deixei dessa forma para facilitar o Delete
                        ctx.stroke();
                        }
                }else{
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    for(var i = 0; ((i*2)+1)<arraux.length;i++){
                        ctx.lineTo(arraux[i*2],arraux[(i*2)+1]);
                        ctx.stroke();
                        } 
                }
            }
        }
    }
    function drawCurve(){//Desenha as curvas
    //Para saber se vai pintar, segue o mesmo rumo... Checkbox, variavel e pah
        var checkCurve = document.getElementsByName("Curves");
        var pointes = [];
        if(checkCurve[0].checked){
            for(var j = 0; j<matriz.length;j++){
                var c = document.getElementById("canvas");
                var ctx = c.getContext("2d");
                var arraux = matriz[j];
                ctx.beginPath();
                ctx.moveTo(arraux[0],arraux[1]);//Move para o primeiro ponto
                for(var i = 0; i<=1;i+=(1/avaliat)){
                    pointes = bezier(i,arraux);//X e Y que vem do bezier
                    if(aktObj === j){
                        ctx.strokeStyle = '#0084ff';
                        console.log(pointes);
                        ctx.lineTo(pointes[0],pointes[1]);//Faz uma linha até o ponto encontrado
                        ctx.stroke();
                    }else{
                        ctx.strokeStyle = '#000000';
                        console.log(pointes);
                        ctx.lineTo(pointes[0],pointes[1]);
                        ctx.stroke();
                    }
                }
                if(aktObj === j){
                    ctx.strokeStyle = '#0084ff';
                    console.log(pointes);
                    ctx.lineTo(arraux[arraux.length-2],arraux[arraux.length-1]);//Faz uma linha até o ponto encontrado
                    ctx.stroke();
                }else{
                    ctx.strokeStyle = '#000000';
                    console.log(pointes);
                    ctx.lineTo(arraux[arraux.length-2],arraux[arraux.length-1]);//Faz uma linha até o ponto encontrado
                    ctx.stroke();
                }
            } 
        }
    }
    function bezier(t,arr){//Recebe o T que varia de 0 a 1 e o array de pontos
    //Como dito anteriormente o array de ponto fica [x0,y0,x1,y1,x2,y2...]
        var n = arr.length/2;
        var aupx = [];
        var retorm = [];
        console.log(arr);
        //Tava dando uns bugs, então passei para os arrays antes
        for(var k = 0; (k*2)<arr.length;k++){
            aupx.push(Math.floor(arr[k*2]));
        }
        var aupy = [];
        for(var k = 0; ((k*2)+1)<arr.length;k++){
            aupy.push(Math.floor(arr[(k*2)+1]));
        }
        console.log(aupx);
        console.log(aupy);
        for(var k =1;k<=n;k++){
            for(var p =0;p<=(n-k)-1;p++){
                aupx[p] = (1-t)*aupx[p] + t*aupx[p+1];//Encontra posicoes de X
                aupy[p] = (1-t)*aupy[p] + t*aupy[p+1];//Encontra posicoes de Y
            }
        }
        retorm.push(aupx[0]);
        retorm.push(aupy[0]);
        return retorm;
    }
    function reset(){//Pinta o quadro de branco e redesenha todos os itens.
        if(!doPoint){//Como a cada click na tela reseto, caso esteja fazendo os pontos, ele não irá resetar
            ctx.fillStyle = "#FFFFFF";
            ctx.beginPath();
            ctx.fillRect(0,0,750,500);
            ctx.stroke();
            drawPoliCtrl();
            drawPoints()
            drawCurve();
            ctx.strokeStyle = '#000000';
        }
    }
  </script>
</html>